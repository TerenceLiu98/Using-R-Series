indent1 = '    '
indent2 = paste(rep(indent1, 2), collapse='')
indent3 = paste(rep(indent1, 3), collapse='')
doeval = TRUE
doecho = FALSE
library(tidyverse)
# rmarkdown initialization
library(knitr)
options(digits=6)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE,results='asis')
library(texreg)
library(lmtest)
#library(rJava)
#library(xlsx) ## reading from `.xlsx` file
library(tidyquant)
library(timetk)
library(glue)
library(broom)  # to call the function `tidy()`
library(quantmod)
library(tseries)
library(timeSeries)
library(forecast)
library(xts)
library(highcharter)
# READING `IBKC` ..
stock_ibkc <- read.csv("IBKC.csv") #%>% as.tbl
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_ibkc)
# select the relevant close price series
stockts_ibkc <- stock_ibkc[,5]
stockts_MBWM <- stock_MBWM[,5]
stockts_SBNY <- stock_SBNY[,5]
#Plot the original data
head(stockts_ibkc)
x <- ts(stockts_ibkc,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
y <- ts(stockts_MBWM ,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
z <- ts(stockts_SBNY,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
ts.plot(x,y,z,gpars = list(col=c("blue","red","black")))
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_ibkc <- diff(log(stockts_ibkc),lag=1) #%>% as.tbl
logret_ibkc <- logret_ibkc[!is.na(logret_ibkc)]
head(logret_ibkc)
# Plot log returns
plot(logret_ibkc,type='l', main='log returns plot for IBKC')
##################################################
##################################################
# READING `MBWM` ..
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
head(stock_MBWM)
# select the relevant close price series
stockts_MBWM <- stock_MBWM[,5]
head(stockts_MBWM)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_MBWM <- diff(log(stockts_MBWM),lag=1) #%>% as.tbl
logret_MBWM <- logret_MBWM[!is.na(logret_MBWM)]
head(logret_MBWM)
# Plot log returns
plot(logret_MBWM,type='l', main='Log-Returns Plot for MBWM')
##################################################
##################################################
# READING `SBNY` ..
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_SBNY)
# select the relevant close price series
stockts_SBNY <- stock_SBNY[,5]
head(stockts_SBNY)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_SBNY <- diff(log(stockts_SBNY),lag=1) #%>% as.tbl
logret_SBNY <- logret_SBNY[!is.na(logret_SBNY)]
head(logret_SBNY)
# Plot log returns
plot(logret_SBNY,type='l', main='Log-Returns Plot for SBNY')
##################################################
##################################################
# Conduct ADF test on log returns series
print(adf.test(logret_ibkc))
# Split the dataset in two parts - training and testing
length_ibkc <- length(logret_ibkc)[1]
breakpoint <- floor(length_ibkc*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_ibkc <- acf(logret_ibkc[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_ibkc <- pacf(logret_ibkc[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_MBWM))
# Split the dataset in two parts - training and testing
length_MBWM <- length(logret_MBWM)[1]
breakpoint <- floor(length_MBWM*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_MBWM <- acf(logret_MBWM[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_MBWM <- pacf(logret_MBWM[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_SBNY))
# Split the dataset in two parts - training and testing
length_SBNY <- length(logret_SBNY)[1]
breakpoint <- floor(length_SBNY*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_SBNY <- acf(logret_SBNY[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_SBNY <- pacf(logret_SBNY[c(1:breakpoint)], main='PACF Plot', lag.max=100)
IBKC.fit <- auto.arima(stockts_ibkc, seasonal=FALSE)
summary(IBKC.fit)
tsdisplay(residuals(IBKC.fit), lag.max=45, main='(2,0,2) Model Residuals for IBKC')
IBKC.fit2 <- arima(stockts_ibkc, order=c(2,0,0))
tsdisplay(residuals(IBKC.fit2), lag.max=15, main='Seasonal Model Residuals for IBKC')
IBKC.fcast1 <- forecast(IBKC.fit, h=500)
IBKC.fcast2 <- forecast(IBKC.fit2, h=500)
IBKC.accuracy1 <- accuracy(IBKC.fcast1)
IBKC.accuracy2 <- accuracy(IBKC.fcast2)
IBKC.accuracy1;IBKC.accuracy2
plot(IBKC.fcast1)
plot(IBKC.fcast2)
MBWM.fit <- auto.arima(stockts_MBWM, seasonal=FALSE)
summary(MBWM.fit)
tsdisplay(residuals(MBWM.fit), lag.max=45, main='(2,0,2) Model Residuals for MBWM')
MBWM.fit2 <- arima(stockts_MBWM, order=c(2,0,0))
tsdisplay(residuals(MBWM.fit2), lag.max=15, main='Seasonal Model Residuals for MBWM')
MBWM.fcast1 <- forecast(MBWM.fit, h=500)
MBWM.fcast2 <- forecast(MBWM.fit2, h=500)
# Accuracy
MBWM.accuracy1 <- accuracy(MBWM.fcast1)
MBWM.accuracy2 <- accuracy(MBWM.fcast2)
MBWM.accuracy1;MBWM.accuracy2
# Plot the graph
plot(MBWM.fcast1)
plot(MBWM.fcast2)
SBNY.fit <- auto.arima(stockts_SBNY, seasonal=FALSE)
summary(SBNY.fit)
tsdisplay(residuals(SBNY.fit), lag.max=45, main='(2,0,2) Model Residuals for SBNY')
SBNY.fit2 <- arima(stockts_SBNY, order=c(2,0,0))
tsdisplay(residuals(SBNY.fit2), lag.max=15, main='Seasonal Model Residuals for SBNY')
SBNY.fcast1 <- forecast(SBNY.fit, h=500)
SBNY.fcast2 <- forecast(SBNY.fit2, h=500)
# Accuracy
SBNY.accuracy1 <- accuracy(SBNY.fcast1)
SBNY.accuracy2 <- accuracy(SBNY.fcast2)
SBNY.accuracy1;SBNY.accuracy2
# Plot the graph
plot(SBNY.fcast1)
plot(SBNY.fcast2)
# Initialzing an xts object for Actual log returns
Actual_series <- xts(0,as.Date("2014-11-25","%Y-%m-%d"))
# Initialzing a dataframe for the forecasted return series
forecasted_series <- data.frame(Forecasted = numeric())
for (b in breakpoint:(length_ibkc-1)) {
stockts_ibkc_train = stockts_ibkc[1:b]
stockts_ibkc_test = stockts_ibkc[(b+1):length_ibkc]
# Summary of the ARIMA model using the determined (p,d,q) parameters
fit = arima(stockts_ibkc_train, order = c(2, 0, 2))
summary(fit)
# plotting a acf plot of the residuals
acf(fit$residuals,main="Residuals plot")
# Forecasting the log returns
arima.forecast <- forecast(fit, h = 1,level=99)
summary(arima.forecast)
# plotting the forecast
par(mfrow=c(1,1))
plot(arima.forecast, main = "ARIMA Forecast")
# Creating a series of forecasted returns for the forecasted period
forecasted_series <- rbind(forecasted_series,arima.forecast$mean[1])
colnames(forecasted_series) = c("Forecasted")
# Creating a series of actual returns for the forecasted period
Actual_return <- logret_ibkc[(b+1)]
Actual_series <- c(Actual_series,xts(Actual_return))
rm(Actual_return)
print(logret_ibkc_prices[(b+1)])
print(logret_ibkc_prices[(b+2)])
}
#knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
indent1 = '    '
indent2 = paste(rep(indent1, 2), collapse='')
indent3 = paste(rep(indent1, 3), collapse='')
doeval = TRUE
doecho = FALSE
library(tidyverse)
# rmarkdown initialization
library(knitr)
options(digits=6)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE,results='asis')
library(texreg)
library(lmtest)
#library(rJava)
#library(xlsx) ## reading from `.xlsx` file
library(tidyquant)
library(timetk)
library(glue)
library(broom)  # to call the function `tidy()`
library(quantmod)
library(tseries)
library(timeSeries)
library(forecast)
library(xts)
library(highcharter)
# READING `IBKC` ..
stock_ibkc <- read.csv("IBKC.csv") #%>% as.tbl
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_ibkc)
# select the relevant close price series
stockts_ibkc <- stock_ibkc[,5]
stockts_MBWM <- stock_MBWM[,5]
stockts_SBNY <- stock_SBNY[,5]
#Plot the original data
head(stockts_ibkc)
x <- ts(stockts_ibkc,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
y <- ts(stockts_MBWM ,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
z <- ts(stockts_SBNY,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
ts.plot(x,y,z,gpars = list(col=c("blue","red","black")))
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_ibkc <- diff(log(stockts_ibkc),lag=1) #%>% as.tbl
logret_ibkc <- logret_ibkc[!is.na(logret_ibkc)]
head(logret_ibkc)
# Plot log returns
plot(logret_ibkc,type='l', main='log returns plot for IBKC')
##################################################
##################################################
# READING `MBWM` ..
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
head(stock_MBWM)
# select the relevant close price series
stockts_MBWM <- stock_MBWM[,5]
head(stockts_MBWM)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_MBWM <- diff(log(stockts_MBWM),lag=1) #%>% as.tbl
logret_MBWM <- logret_MBWM[!is.na(logret_MBWM)]
head(logret_MBWM)
# Plot log returns
plot(logret_MBWM,type='l', main='Log-Returns Plot for MBWM')
##################################################
##################################################
# READING `SBNY` ..
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_SBNY)
# select the relevant close price series
stockts_SBNY <- stock_SBNY[,5]
head(stockts_SBNY)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_SBNY <- diff(log(stockts_SBNY),lag=1) #%>% as.tbl
logret_SBNY <- logret_SBNY[!is.na(logret_SBNY)]
head(logret_SBNY)
# Plot log returns
plot(logret_SBNY,type='l', main='Log-Returns Plot for SBNY')
##################################################
##################################################
# Conduct ADF test on log returns series
print(adf.test(logret_ibkc))
# Split the dataset in two parts - training and testing
length_ibkc <- length(logret_ibkc)[1]
breakpoint <- floor(length_ibkc*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_ibkc <- acf(logret_ibkc[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_ibkc <- pacf(logret_ibkc[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_MBWM))
# Split the dataset in two parts - training and testing
length_MBWM <- length(logret_MBWM)[1]
breakpoint <- floor(length_MBWM*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_MBWM <- acf(logret_MBWM[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_MBWM <- pacf(logret_MBWM[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_SBNY))
# Split the dataset in two parts - training and testing
length_SBNY <- length(logret_SBNY)[1]
breakpoint <- floor(length_SBNY*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_SBNY <- acf(logret_SBNY[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_SBNY <- pacf(logret_SBNY[c(1:breakpoint)], main='PACF Plot', lag.max=100)
IBKC.fit <- auto.arima(stockts_ibkc, seasonal=FALSE)
summary(IBKC.fit)
tsdisplay(residuals(IBKC.fit), lag.max=45, main='(2,0,2) Model Residuals for IBKC')
IBKC.fit2 <- arima(stockts_ibkc, order=c(2,0,0))
tsdisplay(residuals(IBKC.fit2), lag.max=15, main='Seasonal Model Residuals for IBKC')
IBKC.fcast1 <- forecast(IBKC.fit, h=500)
IBKC.fcast2 <- forecast(IBKC.fit2, h=500)
IBKC.accuracy1 <- accuracy(IBKC.fcast1)
IBKC.accuracy2 <- accuracy(IBKC.fcast2)
IBKC.accuracy1;IBKC.accuracy2
plot(IBKC.fcast1)
plot(IBKC.fcast2)
MBWM.fit <- auto.arima(stockts_MBWM, seasonal=FALSE)
summary(MBWM.fit)
tsdisplay(residuals(MBWM.fit), lag.max=45, main='(2,0,2) Model Residuals for MBWM')
MBWM.fit2 <- arima(stockts_MBWM, order=c(2,0,0))
tsdisplay(residuals(MBWM.fit2), lag.max=15, main='Seasonal Model Residuals for MBWM')
MBWM.fcast1 <- forecast(MBWM.fit, h=500)
MBWM.fcast2 <- forecast(MBWM.fit2, h=500)
# Accuracy
MBWM.accuracy1 <- accuracy(MBWM.fcast1)
MBWM.accuracy2 <- accuracy(MBWM.fcast2)
MBWM.accuracy1;MBWM.accuracy2
# Plot the graph
plot(MBWM.fcast1)
plot(MBWM.fcast2)
SBNY.fit <- auto.arima(stockts_SBNY, seasonal=FALSE)
summary(SBNY.fit)
tsdisplay(residuals(SBNY.fit), lag.max=45, main='(2,0,2) Model Residuals for SBNY')
SBNY.fit2 <- arima(stockts_SBNY, order=c(2,0,0))
tsdisplay(residuals(SBNY.fit2), lag.max=15, main='Seasonal Model Residuals for SBNY')
SBNY.fcast1 <- forecast(SBNY.fit, h=500)
SBNY.fcast2 <- forecast(SBNY.fit2, h=500)
# Accuracy
SBNY.accuracy1 <- accuracy(SBNY.fcast1)
SBNY.accuracy2 <- accuracy(SBNY.fcast2)
SBNY.accuracy1;SBNY.accuracy2
# Plot the graph
plot(SBNY.fcast1)
plot(SBNY.fcast2)
# Initialzing an xts object for Actual log returns
# Initialzing a dataframe for the forecasted return series
forecasted_series <- data.frame(Forecasted = numeric())
for (b in breakpoint:(length_ibkc-1)) {
stockts_ibkc_train = stockts_ibkc[1:b]
stockts_ibkc_test = stockts_ibkc[(b+1):length_ibkc]
# Summary of the ARIMA model using the determined (p,d,q) parameters
fit = arima(stockts_ibkc_train, order = c(2, 0, 2))
summary(fit)
# plotting a acf plot of the residuals
acf(fit$residuals,main="Residuals plot")
# Forecasting the log returns
arima.forecast <- forecast(fit, h = 1,level=99)
summary(arima.forecast)
# plotting the forecast
par(mfrow=c(1,1))
plot(arima.forecast, main = "ARIMA Forecast")
# Creating a series of forecasted returns for the forecasted period
forecasted_series <- rbind(forecasted_series,arima.forecast$mean[1])
colnames(forecasted_series) = c("Forecasted")
# Creating a series of actual returns for the forecasted period
Actual_return <- logret_ibkc[(b+1)]
Actual_series <- c(Actual_series,xts(Actual_return))
rm(Actual_return)
print(logret_ibkc_prices[(b+1)])
print(logret_ibkc_prices[(b+2)])
}
#knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
indent1 = '    '
indent2 = paste(rep(indent1, 2), collapse='')
indent3 = paste(rep(indent1, 3), collapse='')
doeval = TRUE
doecho = FALSE
library(tidyverse)
# rmarkdown initialization
library(knitr)
options(digits=6)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE,results='asis')
library(texreg)
library(lmtest)
#library(rJava)
#library(xlsx) ## reading from `.xlsx` file
library(tidyquant)
library(timetk)
library(glue)
library(broom)  # to call the function `tidy()`
library(quantmod)
library(tseries)
library(timeSeries)
library(forecast)
library(xts)
library(highcharter)
# READING `IBKC` ..
stock_ibkc <- read.csv("IBKC.csv") #%>% as.tbl
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_ibkc)
# select the relevant close price series
stockts_ibkc <- stock_ibkc[,5]
stockts_MBWM <- stock_MBWM[,5]
stockts_SBNY <- stock_SBNY[,5]
#Plot the original data
head(stockts_ibkc)
x <- ts(stockts_ibkc,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
y <- ts(stockts_MBWM ,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
z <- ts(stockts_SBNY,frequency = 365, start = c(2008,08,06), end = c(2018,08,06))
ts.plot(x,y,z,gpars = list(col=c("blue","red","black")))
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_ibkc <- diff(log(stockts_ibkc),lag=1) #%>% as.tbl
logret_ibkc <- logret_ibkc[!is.na(logret_ibkc)]
head(logret_ibkc)
# Plot log returns
plot(logret_ibkc,type='l', main='log returns plot for IBKC')
##################################################
##################################################
# READING `MBWM` ..
stock_MBWM <- read.csv("MBWM.csv") #%>% as.tbl
head(stock_MBWM)
# select the relevant close price series
stockts_MBWM <- stock_MBWM[,5]
head(stockts_MBWM)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_MBWM <- diff(log(stockts_MBWM),lag=1) #%>% as.tbl
logret_MBWM <- logret_MBWM[!is.na(logret_MBWM)]
head(logret_MBWM)
# Plot log returns
plot(logret_MBWM,type='l', main='Log-Returns Plot for MBWM')
##################################################
##################################################
# READING `SBNY` ..
stock_SBNY <- read.csv("SBNY.csv") #%>% as.tbl
head(stock_SBNY)
# select the relevant close price series
stockts_SBNY <- stock_SBNY[,5]
head(stockts_SBNY)
# Compute the log returns for the stock
# the source of inconvenience come from view of time seires
logret_SBNY <- diff(log(stockts_SBNY),lag=1) #%>% as.tbl
logret_SBNY <- logret_SBNY[!is.na(logret_SBNY)]
head(logret_SBNY)
# Plot log returns
plot(logret_SBNY,type='l', main='Log-Returns Plot for SBNY')
##################################################
##################################################
# Conduct ADF test on log returns series
print(adf.test(logret_ibkc))
# Split the dataset in two parts - training and testing
length_ibkc <- length(logret_ibkc)[1]
breakpoint <- floor(length_ibkc*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_ibkc <- acf(logret_ibkc[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_ibkc <- pacf(logret_ibkc[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_MBWM))
# Split the dataset in two parts - training and testing
length_MBWM <- length(logret_MBWM)[1]
breakpoint <- floor(length_MBWM*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_MBWM <- acf(logret_MBWM[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_MBWM <- pacf(logret_MBWM[c(1:breakpoint)], main='PACF Plot', lag.max=100)
# Conduct ADF test on log returns series
print(adf.test(logret_SBNY))
# Split the dataset in two parts - training and testing
length_SBNY <- length(logret_SBNY)[1]
breakpoint <- floor(length_SBNY*(2.9/3))
# Apply the ACF and PACF functions
par(mfrow = c(1,1))
acf.logret_SBNY <- acf(logret_SBNY[c(1:breakpoint)], main='ACF Plot', lag.max=100)
pacf.logret_SBNY <- pacf(logret_SBNY[c(1:breakpoint)], main='PACF Plot', lag.max=100)
IBKC.fit <- auto.arima(stockts_ibkc, seasonal=FALSE)
summary(IBKC.fit)
tsdisplay(residuals(IBKC.fit), lag.max=45, main='(2,0,2) Model Residuals for IBKC')
IBKC.fit2 <- arima(stockts_ibkc, order=c(2,0,0))
tsdisplay(residuals(IBKC.fit2), lag.max=15, main='Seasonal Model Residuals for IBKC')
IBKC.fcast1 <- forecast(IBKC.fit, h=500)
IBKC.fcast2 <- forecast(IBKC.fit2, h=500)
IBKC.accuracy1 <- accuracy(IBKC.fcast1)
IBKC.accuracy2 <- accuracy(IBKC.fcast2)
IBKC.accuracy1;IBKC.accuracy2
plot(IBKC.fcast1)
plot(IBKC.fcast2)
MBWM.fit <- auto.arima(stockts_MBWM, seasonal=FALSE)
summary(MBWM.fit)
tsdisplay(residuals(MBWM.fit), lag.max=45, main='(2,0,2) Model Residuals for MBWM')
MBWM.fit2 <- arima(stockts_MBWM, order=c(2,0,0))
tsdisplay(residuals(MBWM.fit2), lag.max=15, main='Seasonal Model Residuals for MBWM')
MBWM.fcast1 <- forecast(MBWM.fit, h=500)
MBWM.fcast2 <- forecast(MBWM.fit2, h=500)
# Accuracy
MBWM.accuracy1 <- accuracy(MBWM.fcast1)
MBWM.accuracy2 <- accuracy(MBWM.fcast2)
MBWM.accuracy1;MBWM.accuracy2
# Plot the graph
plot(MBWM.fcast1)
plot(MBWM.fcast2)
SBNY.fit <- auto.arima(stockts_SBNY, seasonal=FALSE)
summary(SBNY.fit)
tsdisplay(residuals(SBNY.fit), lag.max=45, main='(2,0,2) Model Residuals for SBNY')
SBNY.fit2 <- arima(stockts_SBNY, order=c(2,0,0))
tsdisplay(residuals(SBNY.fit2), lag.max=15, main='Seasonal Model Residuals for SBNY')
SBNY.fcast1 <- forecast(SBNY.fit, h=500)
SBNY.fcast2 <- forecast(SBNY.fit2, h=500)
# Accuracy
SBNY.accuracy1 <- accuracy(SBNY.fcast1)
SBNY.accuracy2 <- accuracy(SBNY.fcast2)
SBNY.accuracy1;SBNY.accuracy2
# Plot the graph
plot(SBNY.fcast1)
plot(SBNY.fcast2)
# Initialzing an xts object for Actual log returns
# Summary of the ARIMA model using the determined (p,d,q) parameters
fit = arima(stockts_ibkc_train, order = c(2, 0, 2))
summary(fit)
# plotting a acf plot of the residuals
acf(fit$residuals,main="Residuals plot")
# Forecasting the log returns
arima.forecast <- forecast(fit, h = 1,level=99)
summary(arima.forecast)
# plotting the forecast
par(mfrow=c(1,1))
plot(arima.forecast, main = "ARIMA Forecast")
# Creating a series of forecasted returns for the forecasted period
forecasted_series <- rbind(forecasted_series,arima.forecast$mean[1])
colnames(forecasted_series) = c("Forecasted")
# Creating a series of actual returns for the forecasted period
Actual_return <- logret_ibkc[(b+1)]
Actual_series <- c(Actual_series,xts(Actual_return))
#knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
q() # attention! DO NOT RUN THIS CODE IN THIS MOMENT
